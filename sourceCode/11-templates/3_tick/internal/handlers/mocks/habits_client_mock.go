// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i learngo-pockets/templates/internal/handlers.habitsClient -o habits_client_mock.go -n HabitsClientMock -p mocks

import (
	"context"
	"learngo-pockets/templates/internal/habit"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// HabitsClientMock implements handlers.habitsClient
type HabitsClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcListHabits          func(ctx context.Context, t time.Time) (ha1 []habit.Habit, err error)
	inspectFuncListHabits   func(ctx context.Context, t time.Time)
	afterListHabitsCounter  uint64
	beforeListHabitsCounter uint64
	ListHabitsMock          mHabitsClientMockListHabits

	funcTickHabit          func(ctx context.Context, id habit.ID) (err error)
	inspectFuncTickHabit   func(ctx context.Context, id habit.ID)
	afterTickHabitCounter  uint64
	beforeTickHabitCounter uint64
	TickHabitMock          mHabitsClientMockTickHabit
}

// NewHabitsClientMock returns a mock for handlers.habitsClient
func NewHabitsClientMock(t minimock.Tester) *HabitsClientMock {
	m := &HabitsClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ListHabitsMock = mHabitsClientMockListHabits{mock: m}
	m.ListHabitsMock.callArgs = []*HabitsClientMockListHabitsParams{}

	m.TickHabitMock = mHabitsClientMockTickHabit{mock: m}
	m.TickHabitMock.callArgs = []*HabitsClientMockTickHabitParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mHabitsClientMockListHabits struct {
	mock               *HabitsClientMock
	defaultExpectation *HabitsClientMockListHabitsExpectation
	expectations       []*HabitsClientMockListHabitsExpectation

	callArgs []*HabitsClientMockListHabitsParams
	mutex    sync.RWMutex
}

// HabitsClientMockListHabitsExpectation specifies expectation struct of the habitsClient.ListHabits
type HabitsClientMockListHabitsExpectation struct {
	mock    *HabitsClientMock
	params  *HabitsClientMockListHabitsParams
	results *HabitsClientMockListHabitsResults
	Counter uint64
}

// HabitsClientMockListHabitsParams contains parameters of the habitsClient.ListHabits
type HabitsClientMockListHabitsParams struct {
	ctx context.Context
	t   time.Time
}

// HabitsClientMockListHabitsResults contains results of the habitsClient.ListHabits
type HabitsClientMockListHabitsResults struct {
	ha1 []habit.Habit
	err error
}

// Expect sets up expected params for habitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Expect(ctx context.Context, t time.Time) *mHabitsClientMockListHabits {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	if mmListHabits.defaultExpectation == nil {
		mmListHabits.defaultExpectation = &HabitsClientMockListHabitsExpectation{}
	}

	mmListHabits.defaultExpectation.params = &HabitsClientMockListHabitsParams{ctx, t}
	for _, e := range mmListHabits.expectations {
		if minimock.Equal(e.params, mmListHabits.defaultExpectation.params) {
			mmListHabits.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListHabits.defaultExpectation.params)
		}
	}

	return mmListHabits
}

// Inspect accepts an inspector function that has same arguments as the habitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Inspect(f func(ctx context.Context, t time.Time)) *mHabitsClientMockListHabits {
	if mmListHabits.mock.inspectFuncListHabits != nil {
		mmListHabits.mock.t.Fatalf("Inspect function is already set for HabitsClientMock.ListHabits")
	}

	mmListHabits.mock.inspectFuncListHabits = f

	return mmListHabits
}

// Return sets up results that will be returned by habitsClient.ListHabits
func (mmListHabits *mHabitsClientMockListHabits) Return(ha1 []habit.Habit, err error) *HabitsClientMock {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	if mmListHabits.defaultExpectation == nil {
		mmListHabits.defaultExpectation = &HabitsClientMockListHabitsExpectation{mock: mmListHabits.mock}
	}
	mmListHabits.defaultExpectation.results = &HabitsClientMockListHabitsResults{ha1, err}
	return mmListHabits.mock
}

// Set uses given function f to mock the habitsClient.ListHabits method
func (mmListHabits *mHabitsClientMockListHabits) Set(f func(ctx context.Context, t time.Time) (ha1 []habit.Habit, err error)) *HabitsClientMock {
	if mmListHabits.defaultExpectation != nil {
		mmListHabits.mock.t.Fatalf("Default expectation is already set for the habitsClient.ListHabits method")
	}

	if len(mmListHabits.expectations) > 0 {
		mmListHabits.mock.t.Fatalf("Some expectations are already set for the habitsClient.ListHabits method")
	}

	mmListHabits.mock.funcListHabits = f
	return mmListHabits.mock
}

// When sets expectation for the habitsClient.ListHabits which will trigger the result defined by the following
// Then helper
func (mmListHabits *mHabitsClientMockListHabits) When(ctx context.Context, t time.Time) *HabitsClientMockListHabitsExpectation {
	if mmListHabits.mock.funcListHabits != nil {
		mmListHabits.mock.t.Fatalf("HabitsClientMock.ListHabits mock is already set by Set")
	}

	expectation := &HabitsClientMockListHabitsExpectation{
		mock:   mmListHabits.mock,
		params: &HabitsClientMockListHabitsParams{ctx, t},
	}
	mmListHabits.expectations = append(mmListHabits.expectations, expectation)
	return expectation
}

// Then sets up habitsClient.ListHabits return parameters for the expectation previously defined by the When method
func (e *HabitsClientMockListHabitsExpectation) Then(ha1 []habit.Habit, err error) *HabitsClientMock {
	e.results = &HabitsClientMockListHabitsResults{ha1, err}
	return e.mock
}

// ListHabits implements handlers.habitsClient
func (mmListHabits *HabitsClientMock) ListHabits(ctx context.Context, t time.Time) (ha1 []habit.Habit, err error) {
	mm_atomic.AddUint64(&mmListHabits.beforeListHabitsCounter, 1)
	defer mm_atomic.AddUint64(&mmListHabits.afterListHabitsCounter, 1)

	if mmListHabits.inspectFuncListHabits != nil {
		mmListHabits.inspectFuncListHabits(ctx, t)
	}

	mm_params := HabitsClientMockListHabitsParams{ctx, t}

	// Record call args
	mmListHabits.ListHabitsMock.mutex.Lock()
	mmListHabits.ListHabitsMock.callArgs = append(mmListHabits.ListHabitsMock.callArgs, &mm_params)
	mmListHabits.ListHabitsMock.mutex.Unlock()

	for _, e := range mmListHabits.ListHabitsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ha1, e.results.err
		}
	}

	if mmListHabits.ListHabitsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListHabits.ListHabitsMock.defaultExpectation.Counter, 1)
		mm_want := mmListHabits.ListHabitsMock.defaultExpectation.params
		mm_got := HabitsClientMockListHabitsParams{ctx, t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListHabits.t.Errorf("HabitsClientMock.ListHabits got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListHabits.ListHabitsMock.defaultExpectation.results
		if mm_results == nil {
			mmListHabits.t.Fatal("No results are set for the HabitsClientMock.ListHabits")
		}
		return (*mm_results).ha1, (*mm_results).err
	}
	if mmListHabits.funcListHabits != nil {
		return mmListHabits.funcListHabits(ctx, t)
	}
	mmListHabits.t.Fatalf("Unexpected call to HabitsClientMock.ListHabits. %v %v", ctx, t)
	return
}

// ListHabitsAfterCounter returns a count of finished HabitsClientMock.ListHabits invocations
func (mmListHabits *HabitsClientMock) ListHabitsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHabits.afterListHabitsCounter)
}

// ListHabitsBeforeCounter returns a count of HabitsClientMock.ListHabits invocations
func (mmListHabits *HabitsClientMock) ListHabitsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListHabits.beforeListHabitsCounter)
}

// Calls returns a list of arguments used in each call to HabitsClientMock.ListHabits.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListHabits *mHabitsClientMockListHabits) Calls() []*HabitsClientMockListHabitsParams {
	mmListHabits.mutex.RLock()

	argCopy := make([]*HabitsClientMockListHabitsParams, len(mmListHabits.callArgs))
	copy(argCopy, mmListHabits.callArgs)

	mmListHabits.mutex.RUnlock()

	return argCopy
}

// MinimockListHabitsDone returns true if the count of the ListHabits invocations corresponds
// the number of defined expectations
func (m *HabitsClientMock) MinimockListHabitsDone() bool {
	for _, e := range m.ListHabitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHabitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHabits != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListHabitsInspect logs each unmet expectation
func (m *HabitsClientMock) MinimockListHabitsInspect() {
	for _, e := range m.ListHabitsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HabitsClientMock.ListHabits with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListHabitsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		if m.ListHabitsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HabitsClientMock.ListHabits")
		} else {
			m.t.Errorf("Expected call to HabitsClientMock.ListHabits with params: %#v", *m.ListHabitsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListHabits != nil && mm_atomic.LoadUint64(&m.afterListHabitsCounter) < 1 {
		m.t.Error("Expected call to HabitsClientMock.ListHabits")
	}
}

type mHabitsClientMockTickHabit struct {
	mock               *HabitsClientMock
	defaultExpectation *HabitsClientMockTickHabitExpectation
	expectations       []*HabitsClientMockTickHabitExpectation

	callArgs []*HabitsClientMockTickHabitParams
	mutex    sync.RWMutex
}

// HabitsClientMockTickHabitExpectation specifies expectation struct of the habitsClient.TickHabit
type HabitsClientMockTickHabitExpectation struct {
	mock    *HabitsClientMock
	params  *HabitsClientMockTickHabitParams
	results *HabitsClientMockTickHabitResults
	Counter uint64
}

// HabitsClientMockTickHabitParams contains parameters of the habitsClient.TickHabit
type HabitsClientMockTickHabitParams struct {
	ctx context.Context
	id  habit.ID
}

// HabitsClientMockTickHabitResults contains results of the habitsClient.TickHabit
type HabitsClientMockTickHabitResults struct {
	err error
}

// Expect sets up expected params for habitsClient.TickHabit
func (mmTickHabit *mHabitsClientMockTickHabit) Expect(ctx context.Context, id habit.ID) *mHabitsClientMockTickHabit {
	if mmTickHabit.mock.funcTickHabit != nil {
		mmTickHabit.mock.t.Fatalf("HabitsClientMock.TickHabit mock is already set by Set")
	}

	if mmTickHabit.defaultExpectation == nil {
		mmTickHabit.defaultExpectation = &HabitsClientMockTickHabitExpectation{}
	}

	mmTickHabit.defaultExpectation.params = &HabitsClientMockTickHabitParams{ctx, id}
	for _, e := range mmTickHabit.expectations {
		if minimock.Equal(e.params, mmTickHabit.defaultExpectation.params) {
			mmTickHabit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTickHabit.defaultExpectation.params)
		}
	}

	return mmTickHabit
}

// Inspect accepts an inspector function that has same arguments as the habitsClient.TickHabit
func (mmTickHabit *mHabitsClientMockTickHabit) Inspect(f func(ctx context.Context, id habit.ID)) *mHabitsClientMockTickHabit {
	if mmTickHabit.mock.inspectFuncTickHabit != nil {
		mmTickHabit.mock.t.Fatalf("Inspect function is already set for HabitsClientMock.TickHabit")
	}

	mmTickHabit.mock.inspectFuncTickHabit = f

	return mmTickHabit
}

// Return sets up results that will be returned by habitsClient.TickHabit
func (mmTickHabit *mHabitsClientMockTickHabit) Return(err error) *HabitsClientMock {
	if mmTickHabit.mock.funcTickHabit != nil {
		mmTickHabit.mock.t.Fatalf("HabitsClientMock.TickHabit mock is already set by Set")
	}

	if mmTickHabit.defaultExpectation == nil {
		mmTickHabit.defaultExpectation = &HabitsClientMockTickHabitExpectation{mock: mmTickHabit.mock}
	}
	mmTickHabit.defaultExpectation.results = &HabitsClientMockTickHabitResults{err}
	return mmTickHabit.mock
}

// Set uses given function f to mock the habitsClient.TickHabit method
func (mmTickHabit *mHabitsClientMockTickHabit) Set(f func(ctx context.Context, id habit.ID) (err error)) *HabitsClientMock {
	if mmTickHabit.defaultExpectation != nil {
		mmTickHabit.mock.t.Fatalf("Default expectation is already set for the habitsClient.TickHabit method")
	}

	if len(mmTickHabit.expectations) > 0 {
		mmTickHabit.mock.t.Fatalf("Some expectations are already set for the habitsClient.TickHabit method")
	}

	mmTickHabit.mock.funcTickHabit = f
	return mmTickHabit.mock
}

// When sets expectation for the habitsClient.TickHabit which will trigger the result defined by the following
// Then helper
func (mmTickHabit *mHabitsClientMockTickHabit) When(ctx context.Context, id habit.ID) *HabitsClientMockTickHabitExpectation {
	if mmTickHabit.mock.funcTickHabit != nil {
		mmTickHabit.mock.t.Fatalf("HabitsClientMock.TickHabit mock is already set by Set")
	}

	expectation := &HabitsClientMockTickHabitExpectation{
		mock:   mmTickHabit.mock,
		params: &HabitsClientMockTickHabitParams{ctx, id},
	}
	mmTickHabit.expectations = append(mmTickHabit.expectations, expectation)
	return expectation
}

// Then sets up habitsClient.TickHabit return parameters for the expectation previously defined by the When method
func (e *HabitsClientMockTickHabitExpectation) Then(err error) *HabitsClientMock {
	e.results = &HabitsClientMockTickHabitResults{err}
	return e.mock
}

// TickHabit implements handlers.habitsClient
func (mmTickHabit *HabitsClientMock) TickHabit(ctx context.Context, id habit.ID) (err error) {
	mm_atomic.AddUint64(&mmTickHabit.beforeTickHabitCounter, 1)
	defer mm_atomic.AddUint64(&mmTickHabit.afterTickHabitCounter, 1)

	if mmTickHabit.inspectFuncTickHabit != nil {
		mmTickHabit.inspectFuncTickHabit(ctx, id)
	}

	mm_params := HabitsClientMockTickHabitParams{ctx, id}

	// Record call args
	mmTickHabit.TickHabitMock.mutex.Lock()
	mmTickHabit.TickHabitMock.callArgs = append(mmTickHabit.TickHabitMock.callArgs, &mm_params)
	mmTickHabit.TickHabitMock.mutex.Unlock()

	for _, e := range mmTickHabit.TickHabitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTickHabit.TickHabitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTickHabit.TickHabitMock.defaultExpectation.Counter, 1)
		mm_want := mmTickHabit.TickHabitMock.defaultExpectation.params
		mm_got := HabitsClientMockTickHabitParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTickHabit.t.Errorf("HabitsClientMock.TickHabit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTickHabit.TickHabitMock.defaultExpectation.results
		if mm_results == nil {
			mmTickHabit.t.Fatal("No results are set for the HabitsClientMock.TickHabit")
		}
		return (*mm_results).err
	}
	if mmTickHabit.funcTickHabit != nil {
		return mmTickHabit.funcTickHabit(ctx, id)
	}
	mmTickHabit.t.Fatalf("Unexpected call to HabitsClientMock.TickHabit. %v %v", ctx, id)
	return
}

// TickHabitAfterCounter returns a count of finished HabitsClientMock.TickHabit invocations
func (mmTickHabit *HabitsClientMock) TickHabitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTickHabit.afterTickHabitCounter)
}

// TickHabitBeforeCounter returns a count of HabitsClientMock.TickHabit invocations
func (mmTickHabit *HabitsClientMock) TickHabitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTickHabit.beforeTickHabitCounter)
}

// Calls returns a list of arguments used in each call to HabitsClientMock.TickHabit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTickHabit *mHabitsClientMockTickHabit) Calls() []*HabitsClientMockTickHabitParams {
	mmTickHabit.mutex.RLock()

	argCopy := make([]*HabitsClientMockTickHabitParams, len(mmTickHabit.callArgs))
	copy(argCopy, mmTickHabit.callArgs)

	mmTickHabit.mutex.RUnlock()

	return argCopy
}

// MinimockTickHabitDone returns true if the count of the TickHabit invocations corresponds
// the number of defined expectations
func (m *HabitsClientMock) MinimockTickHabitDone() bool {
	for _, e := range m.TickHabitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TickHabitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTickHabitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTickHabit != nil && mm_atomic.LoadUint64(&m.afterTickHabitCounter) < 1 {
		return false
	}
	return true
}

// MinimockTickHabitInspect logs each unmet expectation
func (m *HabitsClientMock) MinimockTickHabitInspect() {
	for _, e := range m.TickHabitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to HabitsClientMock.TickHabit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TickHabitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTickHabitCounter) < 1 {
		if m.TickHabitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to HabitsClientMock.TickHabit")
		} else {
			m.t.Errorf("Expected call to HabitsClientMock.TickHabit with params: %#v", *m.TickHabitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTickHabit != nil && mm_atomic.LoadUint64(&m.afterTickHabitCounter) < 1 {
		m.t.Error("Expected call to HabitsClientMock.TickHabit")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *HabitsClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockListHabitsInspect()

			m.MinimockTickHabitInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *HabitsClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *HabitsClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockListHabitsDone() &&
		m.MinimockTickHabitDone()
}
